<center><b>数据</b></center>



# 数据



## 基本数据类型

在C语言中，仅有4种基本数据类型——整型、浮点型、指针和聚合类型（如数组和结构等）。



### 整型家族

整型家族包括字符、短整型、整型和长整型，它们都分为有符号和无符号两种版本。



听上去“长整型"所能表示的值应该比“短整型”所能表示的值要大，但这个假设并不一定正确。规定整型值相互之间大小的规则很简单：

长整型至少应该和整型一样长，而整型至少应该和短整型一样长。标准并没有规定长整型必须比短整型长，只是规定它不得比短整型短。

ANSI标准加入了一个规范，说明了各种整型值的最小允许范围，如下表所示：



<center>变量的最小范围</center>

| 类型               | 最小范围                |
| ------------------ | ----------------------- |
| char               | 0到127                  |
| signed char        | -127到127               |
| unsigned char      | 0到255                  |
| short int          | -32767到32767           |
| unsigned short int | 0到65535                |
| int                | -32767到32767           |
| unsigned int       | 0到65535                |
| long int           | -2147483647到2147483647 |
| unsigned long int  | 0到4294967295           |







#### 整型字面值

ANSI C允许命名常量的创建，它与普通变量极为类似。区别在于，当它被初始化以后，它的值便不能改变。



可以在有些字面值的后面添加一个后缀来改变缺省的规则。在整数字面值后面添加字符L或l，可以使这个整数被解释为long型，字符U或u则用于把数值指定为unsigned整型值。如果把这两组字符都添加了，就被解释为unsigned long整型值。



### 浮点类型

浮点数家族包括float、double和long double类型。通常，这些类型分别提供单精度、双精度以及在某些支持扩展精度的机器上提供扩展精度。ANSI标准仅仅规定long double至少和double一样长，而double至少和float一样长。



头文件float.h定义了名字FLT_MAX、DBL_MAX和LDBL_MAX，分别表示float、double和long double所能存储的最大值。而FLT_MIN、DBL_MIN和LDBL_MIN则分别表示最小值。



### 指针

变量的值存储于计算机的内存中，每个变量都占据一个特定的位置。每个内存位置都由地址唯一确定并引用，指针只是地址的另一个名字罢了。指针变量就是一个其值为另外一个（一些）内存地址的变量。C语言拥有一些操作符，可以获得一个变量的地址，也可以通过一个指针变量取得它所指向的值或数据结构。



### 字符串常量

C语言提供了字符串常量。事实上，C语言存在字符串的概念：它就是一串以NUL字节结尾的零个或多个字符。字符串通常存储在字符数组中，这也是C语言没有显式的字符串类型的原因。由于NUL字节是用于终结字符串的，所以在字符串内部不能有NUL字节。



在程序中使用字符串常量会生成一个“指向字符的常量指针”。当一个字符串常量出现于一个表达式中时，表达式所使用的值就是这些字符所存储的地址，而不是这些字符本身。因此，可以把字符串常量赋值给一个“指向字符的指针”，后者指向这些字符所存储的地址。但是，不能把字符串常量赋值给一个字符数组，因为字符串常量的直接值是一个指针，而不是这些字符本身。



## 基本声明

声明表达式可用于声明指针。在C语言的声明中，先给出一个基本类型，紧随其后的是一个标识符列表，这些标识符组成表达式，用于产生基本类型的变量。例如：

```c
int *a;
```

这条语句表示表达式*a产生的结果类型是int。知道了 *  操作符执行的是间接访问操作以后，可以推断a肯定是一个指向int的指针。



注意：

```c
int* b,c,d;
```

中只有b被声明为指针，c和d都只是普通的整型，因此，良好的代码风格应该把 * 写在变量名旁边。



在声明指针变量时，也可以为它指定初始值。

例子：声明一个指针，并用一个字符串常量对其进行初始化：

```c
char *message = "Hello world!";
```

**这条语句把message声明为一个指向字符的指针，并用字符串查看中第一个字符的地址对该指针进行初始化。而且初始值是赋给message本身的，而不**

**是 * message。**



## typedef

C语言支持一种叫做typedef的机制，它允许为各种数据类型定义新名字。typedef声明的写法和普通的声明基本相同，只是把typedef这个关键字出现在声明的前面。例如，下面这个声明：

```c
char *ptr_to_char;
```

把变量ptr_to_char声明为一个指向字符的指针。但是，在添加关键字typedef后，声明变为：

```c
typedef char *ptr_to_char;
```

这个声明把标识符ptr_to_char作为指向字符的指针类型的新名字。可以像使用任何预定义名字一样在下面的声明中使用这个新名字。例如：

```c
ptr_to_char a;	
```

声明a是一个指向字符的指针。



使用typedef声明类型可以减少使声明变得又臭又长的危险，尤其是复杂的声明。



## 常量

ANSI C允许声明常量，常量的样子和变量完全一样，只是它们的值不能修改，可以使用const关键字来声明常量，如下面例子所示：

```c
int const a;
const int a;	
```

这两条语句都把a声明为一个整数，它的值不能被修改。



由于a的值无法被修改，所以无法把任何东西赋值给它。可以在声明时对它进行初始化，如下所示：

```c
int const a = 15;
```

其次，在函数中声明为const的形参在函数被调用时会得到实参的值。



**当涉及到指针变量时，会变得容易混淆：**

```c
int *pi;
```

**pi是一个普通的指向整型的指针。而变量:**

```c
int const *pci;
```

则是一个指向整型常量的指针。可以修改指针的值，但是不能修改它所指向的值。相比之下：

```c
int *const  cpi;
```

**则声明pci为一个指向整型的常量指针。此时指针是常量，它的值无法修改，但可以修改它所指向的整型的值。**

```c
int const * const cpci;
```

**最后，在cpci这个例子里，无论是指针本身还是它所指向的值都是常量，不允许修改。**



#define指令是另一种创建名字常量的机制。例如，下面这两个声明都为50这个值创建了名字常量。

```c
#define MAX_ELEMENTS 50;
int const max_elements = 50;
```

在这种情况下，使用#define比使用const变量更好。因为只要允许使用字面值常量的地方都可以使用前者，比如声明数组的长度。const变量只能用于允许使用变量的地方。



## 链接属性

当组成一个程序的各个源文件分别被编译之后，所有的目标文件以及那些从一个或多个函数库中引用的函数链接在一起，形成可执行程序。然而，如果相同的标识符出现在几个不同的源文件中时，标识符的链接属性决定如何处理在不同文件中出现的标识符。标识符的作用域与它的链接属性有关，但这两个属性并不相同。



***链接属性一共有三种——external（外部）、internal（内部）和none（无）。没有链接属性的标识符总是被当作单独的个体，也就是说该标识符的多个声明被当作独立不同的实体。属于internal链接属性的标识符在同一个源文件内的所有声明中都指同一个实体，但位于不同源文件的多个声明则分属不同的实体。最后，属于external链接属性的标识符不论声明多少次、位于几个源文件都表示同一个实体。***



关键字extern和static用于在声明中修改标识符的链接属性。如果某个声明在正常情况下具有external链接属性，在它前面加上static关键字可以使它的链接属性变为internal。例如，像下面这个不在函数内也不在代码块中的声明：

```c
static int b;
```

那么变量b就将为这个源文件所私有。在其他源文件中，如果也链接到一个叫做b的变量，那么它所引用的是另一个不同的变量。类似，也可以把函数声明为static，如下：

```c
static int c(int d)
```

这可以防止它被其他源文件调用。



static只对缺省链接属性为external的声明才有改变链接属性的效果。



extern关键字的规则更为复杂。一般而言，它为一个标识符指定external链接属性，这样就可以访问在其他任何位置定义的这个实体。例如下面这个例子：

```c
static int i;
int func(){
	int j;
	extern int k;
	extern int i;
}
```

其中的

```c
extern int k;
```

为k指定external链接属性，这样一来，函数就可以访问在其他源文件中声明的外部变量了。

当extern关键字用于源文件中一个标识符的第一次声明时，它指定该标识符具有external链接属性。但是，如果它用于该标识符的第2次或以后的声明时，它并不会更改由第一次声明所指定的链接属性。例如

```c
extern int i;
```

并不修改第一行的声明所指定的变量i的链接属性。



## 存储类型

变量的存储类型是指存储变量值的内存类型。变量的存储类型决定变量何时创建、何时销毁以及他的值将保存多久。有三个地方可以用于存储变量：普通内存、运行堆栈、硬件寄存器。在这三个地方存储的变量具有不同的特性。



变量的缺省存储类型取决于它的声明位置。凡是在任何代码块之外声明的变量总是存储于静态内存中，也就是不属于堆栈的内存，这类变量称为静态变量。对于这类变量，无法为他们指定其他存储类型。静态变量在程序运行之前创建，在程序的整个执行期间始终存在。它始终保存原先的值，除非给它赋一个不同的值或者程序结束。



在代码块内部声明的缺省存储类型的值是自动的，也就是说它存储于堆栈中，称为自动变量。



关键字register可以用于自动变量的声明，提示它们应该存储于机器的硬件寄存器而不是内存中，这类变量称为寄存器变量。通常，寄存器变量比存储于内存的变量访问起来效率更高。但是，编译器不一定要理财register关键字，如果有太多的变量被声明为register，它只选取前几个实际存储于寄存器中，其余的就按普通自动变量处理。



## static关键字

当static用于函数定义时，或用于代码块之外的变量声明时，static关键字用于修改标识符的链接属性，从external改为internal，但标识符的存储类型和作用域不受影响。用这种方式声明的函数或变量只能在声明它们的源文件中访问。



当static用于代码块内部的变量声明时，static关键字用于修改变量的存储类型，从自动变量修改为静态变量，但变量的链接属性和作用域不受影响。用这种方式声明的变量在程序执行之前创建，并在程序的整个执行期间一直存在，而不是每次在代码块开始执行时创建，在代码块执行完毕后销毁。





## 作用域、存储类型示例

```c
int a = 5;
extern int b;
static int c;

int d(int e)
{
	int f = 15;
	register int b;
	static int g = 20;
	extern int a;
	...
	{
		int e;
		int a;
		extern int h;
	}
	...
	{
		int x;
		int e;
		...
	}
	...
}

static int i()
{
	...
}
...	
```



属于文件作用域的声明在缺省情况下为external链接属性，所以第一行的a的链接属性为external。如果b的定义在其他地方，第2行extern关键字在技术上并非必需，但在风格上却是加上这个关键字为好。第三行的static关键字修改了c的缺省链接属性，把它改为internal。声明了a和b（具有external链接属性）的其他源文件在使用这两个变量时实际所访问的是声明于此处的这两个变量。但是，变量c只能由这个源文件访问，因为它具有internal链接属性。



变量a、b、c的存储类型为静态，表示它们并不是存储于堆栈中。因此，这些变量在程序执行之前创建，并一直保存它们的值，直到程序结束。当程序开始执行时，变量a将初始化为5。



这些变量的作用域一直延伸到这个源文件结束为止，但第7行和第13行声明的局部变量a和b在那部分程序中将因此同名的静态变量。



第4行声明了两个标识符。d的作用域从第四行直到文件结束。函数d的定义对于这个源文件中任何以后想要调用它的函数而言起到了函数原型的作用。作为函数名，d在缺省情况下具有external链接属性，所以其他源文件只要在文件上存在d的原型，就可以调用d。如果将函数声明为static，就可以将它的链接属性从external改为internal，但这样做将使其他源文件不能访问这个函数，对于函数而言，存储类型不是问题，因为代码总是存储于静态内存中。



参数e不具有链接属性，所以只能从函数内部通过名字访问它，它具有自动存储类型，所以它在函数被调用时被创建，当函数返回时消失。由于与局部变量冲突，它的作用域限于6-11行、17-19行、23-24行。



6行至8行声明局部变量，所以它们的作用域到函数结束为止。它们不具有链接属性，所以它们不能在函数的外部通过名字访问（这是它们称为局部变量的原因）。f的存储类型是自动，当函数每次被调用时，它通过隐式赋值被初始化为15。***b的存储类型是寄存器类型，所以它的初始值是垃圾。******g的存储类型是静态，所以它在程序的整个执行过程中一直存在。当程序开始执行时，它被初始化为20。当函数每次被调用时，它并不会被重新初始化。***



***9行的声明并不需要，这个代码块位于第一行声明的作用域之内。***



12和13行为代码块声明局部变量。它们都具有自动存储类型，不具有链接属性，它们的作用域延伸至16行，这些变量和先前声明的a和e不同，而且由于名字冲突，在这个代码块中，以前声明的同名变量是不能被访问的。



***14行使全局变量h在这个代码块内可被访问。它具有external链接属性，存储于静态内存中。这是唯一一个必须使用extern关键字的声明，如果没有它，h将变成另一个局部变量。***



19行和20行用于创建局部变量（自动、无链接属性、作用域限于本代码块）。这个e和参数e是不同的变量，它和第12行声明的e也不相同。在这个代码块中，11行到18行并无嵌套，所以编译器可以使用相同的内存来存储两个代码块中不同的变量e。如果想让这两个代码块中的e表示同一个变量，就不应该把它声明为局部变量。



最后，25行声明了函数i，它具有静态链接属性。静态链接属性可以防止它被这个源文件之外的任何函数调用。事实上，其他的源文件也可能声明它自己的函数i，它与这个源文件的i是不同的函数。***i的作用域从它声明的位置直到这个源文件结束。函数d不可以调用函数i，因为在d之前不存在i的原型。***



