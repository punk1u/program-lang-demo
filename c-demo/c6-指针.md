<center><b>指针</b></center>



# 指针



## 内存和地址

可以把计算机的内存看作是一条长街上的一排房屋。每座房子都可以容纳数据，并通过一个房号标识。



这个比喻比较形象，但也存在局限性。计算机的内存由数以亿万计的位（bit）组成，每个位可以容纳值0或1。由于一个位所能表示的值的范围太有限，所以单独的位用处不大，通常许多位合成一组作为一个单位，这样就可以存储范围较大的值。



内存位置的每一个单位为字节（byte），每个字节都包含了存储一个字符所需要的位数。每个字节包含8个位，可以存储无符号位0至255，或有符号位-128至127。每个字节通过地址来标识。



为了存储更大的值，把两个或更多个字节合在一起作为一个更大的内存单位。例如，很多机器以字为单位存储整数，每个字一般由2个或4个字节组成。四个字节组成的字可以容纳的无符号整数的范围是从0至4294967295(2<sup>32</sup>-1)，可以容纳的有符号整数的范围是从-2147483648（-2<sup>31</sup>）至2147483647(2<sup>31</sup>-1)。



需要注意的是，尽管一个字包含了4个字节，它仍然只有一个地址。至于它的地址是它最左边那个字节的位置还是最右边那个字节的位置，不同的机器有不同的规定。另一个需要注意的硬件事项是边界对齐。再要求边界对齐的机器上，整型值存储的起始位置只能是某些特定的字节，通常是2或4的倍数。但这些问题很少影响编写程序，我们只对两件事情感兴趣：

1. 内存中的每个位置有一个独一无二的地址标识。
2. 内存中的每个位置都包含一个值。





### 地址与内容

例子：

| 100  | 104  | 108        | 112  | 116  |
| ---- | ---- | ---------- | ---- | ---- |
| 112  | -1   | 1078523331 | 100  | 108  |



这里显示了5个整数，每个都位于自己的字中。但是直接通过存储地址来获取值太笨拙了。高级语言所提供的特性之一就是通过名字而不是地址来访问内存的位置。



使用名字来替代上面的地址：

| a    | b    | c          | d    | e    |
| ---- | ---- | ---------- | ---- | ---- |
| 112  | -1   | 1078523331 | 100  | 108  |



这些名字就是变量。但是名字与内存位置之间的关联并不是硬件所提供的，它是由编译器提供的——硬件仍然通过地址访问内存位置。



## 值和类型

上面的例子中，头两个位置存储的是整数，第三个位置存储的是非常大的整数，第4、5个位置所存储的也是整数。下面是这些变量的声明：

```c
int a = 112,b = -1;
float c = 3.14;
int *d = &a;
float *e = &c;
```



代码中c所存储的是浮点值，但是在例子中c却是一个整数，那么它到底是整数还是浮点数呢？



答案是该变量包含了一系列内容为0或1的位。它们可以被解释为整数，也可以被解释为浮点数，这取决于它们被使用的方式。如果使用的是整型算术指令，这个值就被解释为整数，如果使用的是浮点型指令，它就是个浮点数。



这个事实引出了一个重要的结论：***不能简单地通过检查一个值的位来判断它的类型。为了判断值的类型（以及它的值），必须观察程序中这个值的使用方式，因为一个值可能被解释为许多种结果。***





## 指针变量的内容



d和e都被声明为指针，并用其他变量的地址予以初始化。**指针的初始化是用&操作符完成的，它用于产生操作数的内存地址。**



d和e的内容是地址而不是整型或浮点数类型。可以很容易地看出，d的内容与a的存储地址一直，而e的内容与c的存储地址一致。



## 间接访问操作符

通过一个指针访问它所指向的过程称为间接访问或解引用指针。这个用于执行间接访问的操作符是单目运算符*。以上面的例子举例：



| 表达式 | 右值 | 类型    |
| ------ | ---- | ------- |
| a      | 112  | int     |
| b      | -1   | int     |
| c      | 3.14 | float   |
| d      | 100  | int *   |
| e      | 108  | float * |
| *d     | 112  | int     |
| *e     | 3.14 | float   |
| &d     | 112  | int     |
| &e     | 116  | int     |



可以看到，d的值就是d所在位置存储的值，也就是&a所获得a变量存储的地址。而*d就是获得  d值在内存中的位置中存储的内容，因为d的值是a变量的地址，所以 * d的值即为a的值。而&d的值则是d在变量在内存中的地址。



还有需要注意的是，d的类型是 int *，即指针类型。



## 未初始化和非法的指针

下面这个代码段说明了一个极为常见的错误：

```c
int *a;
...
*a = 12;
```

***这个声明创建了一个名叫a的指针变量，后面那条赋值语句把12存储在a所指向的内存位置。***



但是a究竟指向哪里呢？声明了这个变量，但从未对其进行初始化，所以没有办法预测12这个值存储于什么地方。从这一点看，指针变量和其他变量并无区别，如果变量是静态的，它会被被初始化为0；但如果变量是自动的，它根本不会被初始化。无论是哪种情况，声明一个指向整型的指针都不会“创建“用于存储整型值的内存空间。



***所以，如果程序执行这个赋值操作，运气好的话，a的初始化会是个非法地址，这样赋值语句会出错，从而终止程序。更为严重的情况是：这个指针偶尔可能包含了一个合法的地址，这样位于那个合法地址的原有值会被修改，像这样类型的错误非常难以捕捉，所以，在对指针进行间接访问前，必须非常小心，确保它们已被初始化。***



## NULL指针

标准定义了NULL指针，它作为一个特殊的指针变量，表示不指向任何东西。要使一个指针变量为NULL，可以给它赋一个零值。为了测试一个指针变量是否为NULL，可以将它与零值比较。选择零这个值是一种代码约定。就机器内部而言，NULL指针的实际值可能与此不同。在这种情况下，编译器负责零值和内部值之间的翻译转换。



NULL指针表示某个特定的指针目前并未指向任何东西。



***对NULL指针进行解引用操作是非法的。在对指针进行解引用操作之前，必须首先确保它并非NULL指针。***



## 指针、间接访问和左值

间接访问操作符所需要的操作数是个右值，但这个操作符所产生的结果是个左值。



给定下面这些声明：

```c
int a;
int *d = &a;
```



| 表达式 | 左值 | 指定位置 |
| ------ | ---- | -------- |
| a      | 是   | a        |
| d      | 是   | d        |
| *d     | 是   | a        |



指针变量可以作为左值，并不是因为它们是指针，而是因为它们是变量。对指针变量进行间接访问表示我们应该访问指针所指向的位置。间接访问指定了一个特定的内存位置，这样可以把间接访问表达式的结果作为左值使用。在下面这两条语句中：

```c
*d = 10 - *d;
d = 10 - *d;
```

***第一条语句包含了两个间接访问操作。右边的间接访问作为右值使用，所以它的值是d指向的位置所存储的值（a的值）。左边的间接访问作为左值使用，所以d所指向的位置（a）把赋值符右侧的表达式的计算结果作为它的新值。***



***第二条语句是非法的，因为它表示把一个整型数量（10-*d）存储于一个指针变量中。当实际使用的变量类型和应该使用的变量类型不一致时，编译器会发出警告和错误信息。***





## 指针、间接访问和变量

```c
*&a = 25;
```

这个表达式的意思是把值25赋值给变量a。



## 指针常量

假定变量a存储于位置100，下面这条语句的作用是什么？

```c
*100 = 25;
```

看上去像是把25赋值给a，因为a是位置100所存储的变量。但是这条语句实际上是非法的，因为字面值100的类型是整型，而间接访问操作只能作用于指针类型表达式。如果确实想把25存储于位置100，必须使用强制类型转换：

```c
*(int *)100 = 25;
```

强制类型转换把值100从“整型”转换为“指向整型的指针”，这样对它进行间接访问就是合法的。但是，基本不可能使用到这种技巧，因为通常无法预测编译器会把某个特定的变量放在内存中的什么位置，所以无法预先知道它的地址。





## 指针的指针

考虑下面这些声明：

```c
int a = 12;
int *b = &a;
int **c = &b;
```

c表示的是指针的指针。

对它进行分析，*操作符具有从右向左的结核性，所以这个表达式相当于 *( *c)，必须从里向外逐层求值。 *c访问c所指向的位置，即变量b。第2个间接访问操作符访问这个位置所指向的地址，也就是变量a。



## 指针实例



### 计算一个字符串的长度

```c
#include <stdlib.h>

size_t strlen(char *string){
    int length = 0;
    /**
     * 依次访问字符串的内容，计数字符数，直到遇见NUL终止符
     */
     while (*string++ != '\0')
         length += 1;
    return length;
}
```



### 在字符串数组中查找指定的字符

```c
#include <stdio.h>

#define TRUE 1
#define FALSE 0

int find_char(char **strings,char value){
    // 表示当前正在查找的字符串
    char *string;

    /**
     * 对于字符串数组中的每个字符串
     */
     while ((string = *strings++) != NULL){
         /**
          * 观察字符串中的每个字符，看看它是不是需要查找的那个
          */
          while (*string != '\0'){
              if (*string++ == value)
                  return TRUE;
          }
     }
    return FALSE;
}
```



## 指针运算

指针可以执行某些运算，但并非所有运算都合法。除了加法运算外，还可以对指针执行一些其他运算，但并不是很多。



***指针加上一个整数的结果是另一个指针。问题是，它指向哪里？如果将一个字符指针加1，运算结果产生的指针指向内存中的下一个字符。float占据的内存空间不止一个字节，如果将一个指向float的指针加1，将会发生什么呢？它会不会指向该float值内部的某个字节呢？***



***幸运的是，答案是否定的。当一个指针和一个整数量执行算术运算时，整数在执行加法运算前始终会根据合适的大小进行调整。这个“合适的大小”就是指针所指向类型的大小，“调整”就是把整数值和“合适的大小”相乘。例如，在某台机器上，float占据4个字节。在计算float型指针加3的表达式时，这个3将根据float的大小（此例中为4）进行调整（相乘）。这样，实际加到指针上的整型值为12。***



***加法运算的美感在于指针算法并不依赖于指针的类型。换句话说，如果p是一个指向char的指针，那么表达式p+1就指向下一个char。如果p是个指向float的指针，那么p+1就指向下一个float。其他类型也是如此。***



### 算术运算

C的指针算术运算只限于两种形式。第一种形式是：

```
指针 +/- 整数
```

并且这类表达式的结果类型也是指针。这种形式也适用于使用malloc函数动态分配获得的内存。



***数组中的元素存储于连续的内存位置中，后面元素的地址大于前面元素的地址。因此，可以很容易地看出，对一个指针加1使它指向数组中下一个元素，加5使它向右移动5个元素的位置，依次类推。***



***对指针执行加法或减法运算之后如果结果指针所指的位置在数组第1个元素的前面或在数组最后一个元素的后面，那么其效果就是未定义的。让指针指向数组最后一个元素后面的那个位置是合法的，但对这个指针执行间接访问可能会失败。***



举个例子，下面的代码通过一个循环，把数组中所有的元素都初始化为零。

```c
#define N_VALUES 5
float values[N_VALUES];
float *vp;

for(vp = &values[0];vp < &values[N_VALUES];)
	*vp++=0;
```

for语句的初始部分把vp指向数组的第1个元素。



算术运算的第二种类型具有如下形式：

```
指针 - 指针
```

***只有当两个指针都指向同一个数组中的元素时，才允许从一个指针减去另一个指针。***



***两个指针相减的结果的类型是ptrdiff_t，它是一种有符号整数类型。减法运算的值是两个指针在内存中的距离（以数组元素的长度为单位，而不是以字节为单位），因为减法运算的结果将除以数组元素类型的长度。***



***如果两个指针指向的不是同一个数组中的元素，那么它们之间相减的结果是未定义的。***



***绝大多数编译器都不会检查指针表达式的结果是否位于合法的边界之内。因此，程序员应该负起责任，确保这一点。类似，编译器不会阻止取一个标量变量的地址并对它执行指针运算，即使无法预测运算结果所产生的指针将指向哪个变量。越界指针和指向未知值的指针是两个常见的错误根源。当使用指针运算时，必须非常小心，确信运算的结果将指向有意义的东西。***



### 关系运算

对指针执行关系运算是有限制的。用下列关系操作符对两个指针值进行比较是可能的：

1. <
2. <=
3. \>
4. \>=



不过前提条件是它们都指向同一个数组中的元素。然而，可以在两个任意的指针间执行相等或不相等测试，因为指针要么指向同一个地址，要么指向不同的地址。



在之前清空数组元素的代码中：

```c
#define N_VALUES 5
float values[N_VALUES];
float *vp;

for(vp = &values[0];vp < &values[N_VALUES];)
	*vp++=0;
```

for语句使用了一个关系测试来决定是否结束循环。这个测试是合法的。



